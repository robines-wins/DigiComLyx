#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
ECSE 411/511
\begin_inset Newline newline
\end_inset

Intro to DigiCom
\end_layout

\begin_layout Author
Marie-Jeanne Lagarde
\begin_inset Newline newline
\end_inset

Robin Solignac
\end_layout

\begin_layout Section*
Course grading system
\end_layout

\begin_layout Itemize
4 assignment 15%
\end_layout

\begin_layout Itemize
Midterm, after SPRING BREAK (march 10), open note 35%
\end_layout

\begin_layout Itemize
final 50%
\end_layout

\begin_deeper
\begin_layout Itemize
411: final exam 2hrs 
\end_layout

\begin_layout Itemize
511: final exam+implementation problem 
\end_layout

\end_deeper
\begin_layout Section*
Courses overview
\end_layout

\begin_layout Enumerate
Data Compression and A/D quantization
\end_layout

\begin_deeper
\begin_layout Itemize
models of data sources with inherent redundancy and fundamental limit on
 quantization and compression
\end_layout

\begin_layout Itemize
quantizers:
\end_layout

\begin_deeper
\begin_layout Itemize
Maximum entropy quantizer, 
\end_layout

\begin_layout Itemize
Max loyd quantizer, 
\end_layout

\begin_layout Itemize
Vector quantization
\end_layout

\end_deeper
\begin_layout Itemize
compression
\end_layout

\begin_deeper
\begin_layout Itemize
Huffman codes (JPEG)
\end_layout

\begin_layout Itemize
Ledpetziv (?) algorithm (zip)
\end_layout

\begin_layout Itemize
run length code
\end_layout

\end_deeper
\begin_layout Itemize
practical
\end_layout

\end_deeper
\begin_layout Enumerate
Analog modulation and channels with noise
\end_layout

\begin_deeper
\begin_layout Itemize
AM/FM radio: 
\end_layout

\begin_deeper
\begin_layout Itemize
Modulation techniques, bandwidth usage, 
\end_layout

\begin_layout Itemize
demodulation techniques and their performance
\end_layout

\end_deeper
\begin_layout Itemize
radio frequency channel for digicom
\end_layout

\end_deeper
\begin_layout Enumerate
Digital modulation and demodulation techniques
\end_layout

\begin_deeper
\begin_layout Itemize
general modulation and demodulation techniques 
\end_layout

\begin_layout Itemize
D-QPSK, Manchester Modulation code,...
\end_layout

\begin_layout Itemize
OFDM: Wi-Fi, 4G
\end_layout

\end_deeper
\begin_layout Enumerate
Theory behind fundamental limits
\end_layout

\begin_deeper
\begin_layout Itemize
entropy
\end_layout

\begin_layout Itemize
capacity of channel: limit on reliable transmission
\end_layout

\begin_layout Itemize
quantization: ray distortion result
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Data compression and Quantization
\end_layout

\begin_layout Chapter
Lossless data compression
\end_layout

\begin_layout Paragraph
Objectives:
\end_layout

\begin_layout Enumerate
Original file = decompressed File
\end_layout

\begin_layout Enumerate
Efficiency, 3:1, 2:1 compression ratio
\end_layout

\begin_layout Paragraph
Questions:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Q1: What is the limit on compression efficiency 
\emph on
on average ? 
\emph default
(answers:
\emph on
 Entropy
\emph default
 of data source is the limit)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Q2: How to do compression/decompression in practice
\end_layout

\begin_layout Subsection
Model of data source
\end_layout

\begin_layout Standard
Random sequence of symbols is emitted by data source.
\end_layout

\begin_layout Paragraph
Source alphabet:
\end_layout

\begin_layout Standard
Emitted symbols are member, and constitute the 
\emph on
source alphabet
\end_layout

\begin_layout Paragraph
Source probabilities:
\end_layout

\begin_layout Standard
probabilities of showing of each symbols.
\end_layout

\begin_layout Itemize
Memoryless source: symbols are independently generated
\end_layout

\begin_layout Itemize
Source with memory: better model.
 ex: Markov source
\begin_inset Foot
status open

\begin_layout Plain Layout
Markov model are use in speech compression 
\end_layout

\end_inset


\end_layout

\begin_layout Section
History
\end_layout

\begin_layout Paragraph
Morse code:
\end_layout

\begin_layout Standard
At the beginning: morse code.
 The telegraph (1840's) trough cable over sea floor.
 Use translation of english alphabet to binary (ternary) symbols.
 and they want the frequency character should be short in binary (i.e E =
 .
 ).
 So they use probabilities: empirically calculated from frequencies in books
\end_layout

\begin_layout Paragraph
earlier compression: (1600)
\end_layout

\begin_layout Standard
Used shutter for transmission with UK of royal command.
 pattern on 4x4 windows (preset message) message send optically and retransmit
 via relay station.
 so 16 bits for each message, but message of different length, The longest:
 
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

by the order of the her/this majesty king/queen the prisoner is to be executed
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Paragraph
kind of compression:
\end_layout

\begin_layout Itemize
Fixed to variable
\end_layout

\begin_layout Itemize
variable to fixed (1980's)
\end_layout

\begin_layout Itemize
variable to variable (zip files)
\end_layout

\begin_layout Itemize
fixed to fixed (2000), turbo compression
\end_layout

\begin_layout Paragraph
Information Entropy:
\end_layout

\begin_layout Standard
How much can I compress the most ? 
\end_layout

\begin_layout Standard
answer: in 1948 Shannon found (in AT&T/Bell labs) the limit to be the 
\emph on
entropy 
\emph default
of the source.
 Cannot compress to fewer bit bits per symbol than entropy
\end_layout

\begin_layout Section
Entropy limit on compression
\end_layout

\begin_layout Itemize
how to calculate it and use it ?
\end_layout

\begin_layout Itemize
why is it true?
\end_layout

\begin_layout Subsection
Definition:
\end_layout

\begin_layout Standard
For a discrete memoryless source 
\begin_inset Formula $X$
\end_inset

 with an alphabet 
\begin_inset Formula $A=\left\{ a_{1},\ldots,a_{n}\right\} $
\end_inset

 and source probabilities 
\begin_inset Formula $p_{1}=P(a_{1}),\ldots p_{n}=P(a_{n})$
\end_inset

, the entropy of the source is 
\begin_inset Formula 
\[
H(X)=\sum_{i=1}^{n}p_{i}\log_{2}\left(\frac{1}{p_{i}}\right)=E_{p_{x}}\left(\log_{2}\frac{1}{p_{x}}\right)
\]

\end_inset

in bits/symbols.
\end_layout

\begin_layout Paragraph
comment:
\end_layout

\begin_layout Enumerate
easy to evaluate
\end_layout

\begin_layout Enumerate
units: Bits (
\begin_inset Formula $\log_{2}$
\end_inset

), bytes (
\begin_inset Formula $\log_{8}$
\end_inset

) or natural units (
\begin_inset Formula $\ln$
\end_inset

), ...
\end_layout

\begin_layout Enumerate
connected to compression 
\end_layout

\begin_layout Subsection
Lossless compression theorem
\end_layout

\begin_layout Standard
For discrete memoryless source 
\begin_inset Formula $X$
\end_inset

 with entropy 
\begin_inset Formula $H(x)$
\end_inset

, you cannot compress to less than 
\begin_inset Formula $H(x)$
\end_inset

 bits.
 And this level can be achieved.
\end_layout

\begin_layout Paragraph
comments:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $H(x)$
\end_inset

 is important, how big/small can it be ? (Maximum when all symbols have
 the same probability)
\begin_inset Foot
status open

\begin_layout Plain Layout
we define 
\begin_inset Formula $0\log0=0$
\end_inset

 Bits/Symbols
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Why is it the limit ?
\end_layout

\begin_layout Paragraph
properties of 
\begin_inset Formula $H(X)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $0\leq H(X)\leq\log_{2}M$
\end_inset

.
 With 
\begin_inset Formula $M$
\end_inset

 the number of symbol
\end_layout

\begin_layout Enumerate
\begin_inset Formula $H(X)=p_{1}\log_{2}\frac{1}{p_{1}},\ldots,p_{n}\log_{2}\frac{1}{p_{n}}=f\left(p_{1},\ldots,p_{n}\right)$
\end_inset

 is a concave function 
\end_layout

\begin_layout Subparagraph
proof of 
\begin_inset Formula $H(X)\geq0$
\end_inset


\end_layout

\begin_layout Standard
since it'a an average of non negative quantities :
\begin_inset Formula $0\leq p_{i}\leq1$
\end_inset

 so 
\begin_inset Formula $\log_{2}\frac{1}{p_{i}}\geq0$
\end_inset

 and so 
\begin_inset Formula $p_{i}\log_{2}\frac{1}{p_{i}}\geq0$
\end_inset

 then it will be positive.
 it's equals 
\begin_inset Formula $0$
\end_inset

 only when 
\begin_inset Formula $\exists n\,:\,p_{n}=1\wedge p_{n}=0\forall m\neq n$
\end_inset

.
\end_layout

\begin_layout Section
Compression algorithm in practice
\end_layout

\begin_layout Paragraph
Motivation
\end_layout

\begin_layout Standard
Start with fixed to variable length compression (like Morse-code)
\end_layout

\begin_layout Standard
compression table:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Source symbols 
\begin_inset Formula $i$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P(X=i)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compressed binary string
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.01$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $000$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.29$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $01$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.70$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Ex : CCCBCCABCCBCC will give 111011100001110111
\end_layout

\begin_layout Standard
So 
\begin_inset Formula $18$
\end_inset

 bits per 
\begin_inset Formula $13$
\end_inset

 source symbol are used: 
\begin_inset Formula $1.38$
\end_inset

 Bits/symbols.
 with fixed to fixed (ascii like symbols representation) we will have 
\begin_inset Formula $2$
\end_inset

 bits/symbols.
\end_layout

\begin_layout Standard
let's compare to 
\begin_inset Formula $H(X)$
\end_inset

.
 
\begin_inset Formula $H(X)=0.94$
\end_inset


\end_layout

\begin_layout Standard
Lower limit on compression is 
\begin_inset Formula $H(X)$
\end_inset

 - Entropy of the source
\end_layout

\begin_layout Standard
Specific codes: Fixed to variable length
\end_layout

\begin_layout Subsection
Uniquely decodable and Prefix Code:
\end_layout

\begin_layout Description
Uniquely-decodable: Ability to decompress without use of commas
\end_layout

\begin_layout Description
Prefix-codes: No binary codeword is a prefix of another codeword
\end_layout

\begin_layout Standard
Prefix codes are 
\emph on
always
\emph default
 uniquely decodable (PC imply UD)
\end_layout

\begin_layout Standard
UD <=> Every compressed file can be uniquely decompressed
\end_layout

\begin_layout Standard
moreover: can be decode instantly without buffering
\end_layout

\begin_layout Subsection
MacMillan inequality:
\end_layout

\begin_layout Paragraph
Pratical design condition:
\end_layout

\begin_layout Standard
Prefixe code exemple:
\end_layout

\begin_layout Standard
a1 - 1 
\end_layout

\begin_layout Standard
a2 - 01
\end_layout

\begin_layout Standard
a3 - 000
\end_layout

\begin_layout Standard
Focus on prefix codes & make then compress to 
\begin_inset Formula $H(x)$
\end_inset


\end_layout

\begin_layout Standard
given sources a1 a2 a3...aM with probabilities p1, p2, p3..pM can I make a prefix
 code with lenghs l1, l2, l3 ? 
\end_layout

\begin_layout Standard
Efficiency of this code 
\begin_inset Formula $E(L)$
\end_inset

 (average number of compressed bits used per store symbols).
 
\begin_inset Formula $E(L)=\sum p_{i}*l_{i}$
\end_inset

( we want it as small as possible)
\end_layout

\begin_layout Standard
Even if wanted code fulfill 
\begin_inset Formula $E(L)\geq H(x)$
\end_inset

, sometime no matter how hard you try you will not get a prefix code or
 UD code
\emph on
 
\end_layout

\begin_layout Paragraph
The MacMillan inequality:
\end_layout

\begin_layout Standard
To see if a such code can be, let's see if ti satisfy the inequality: 
\begin_inset Formula 
\[
2^{-l_{1}}+2^{-l_{2}}+\cdots+2^{-l_{n}}\leq1
\]

\end_inset


\end_layout

\begin_layout Itemize
if it satisfy this inequality we can design a binary then prefix (UD) code
\end_layout

\begin_layout Itemize
if it fails for 
\begin_inset Formula $l_{1},\ldots,l_{n}$
\end_inset

 a prefix (or UD) code cannot be created/Designed
\end_layout

\begin_layout Subsection
Huffman codes
\end_layout

\begin_layout Standard
Now we need a method to design a good prefix code.
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $p_{1},\ldots,p_{n}$
\end_inset

 design a prefix code who satisfy the MacMillan inequality
\end_layout

\begin_layout Enumerate
put symbols-nodes for each symbols at the leaf of a tree, there all free
 they weight is 
\begin_inset Formula $p_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
group the two free nodes who weight sum is the smaller, theses two node
 are not free anymore, the new node is, with weigth equal to the sum of
 connected node
\end_layout

\begin_layout Enumerate
repeat 2.
 until there's only one free node left.
\end_layout

\begin_layout Enumerate
On each none leaf node, label one of it's leaving branch with 
\begin_inset Formula $1$
\end_inset

 and the other with 
\begin_inset Formula $0$
\end_inset


\end_layout

\begin_layout Enumerate
code of each symbol is the sequence made by the label on the branch who
 made the path 
\emph on
from 
\emph default
roots 
\emph on
to
\emph default
 the symbols
\end_layout

\begin_layout Standard
the tree structure guaranties that the prefix condition will hold, So it
 can be used to decompress data: just go along the tree from roots and at
 each step take the labeled branch who match the current symbols, then read
 next symbols until we reach a leaf: the decoded symbols.
 Then start again from roots
\end_layout

\begin_layout Standard
Next step: Answers the why's (we've done the how's), and non Binary codes
\end_layout

\end_body
\end_document
